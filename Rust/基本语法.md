# Rust 语言基本语法

## 一、基本计算

### 1. 整型数据 Integer

像其他大多数语言一样，Rust 也分为有符号（signed）和无符号（unsigned）整数。

**位宽（bit width）**：rust 将整型数据分成了不同的位宽，大致如下:

| Bit width | Signed | Unsigned |
| :-------: | :----: | :------: |
|   8-bit   |  `i8`  |   `u8`   |
|  16-bit   | `i16`  |  `u16`   |
|  32-bit   | `i32`  |  `u32`   |
|  64-bit   | `i64`  |  `u64`   |
|  128-bit  | `i128` |  `u128`  |

> **显式数字**：在没有提供上下文的情况下，Rust 编译器默认将显式数字赋值的变量类型设置为 `i32`， 如果想要使用不同的类型，需要在数字后指定。
>
> ```rust
> let a = 42
> // a 是 类型为 i32 的变量，值为 42
> let b = 42u32
> // b 是 类型为 i32 的变量，值为 42
> ```
>
> **下划线使用**：在表示大数是，可以在数字中使用 下划线 _ 分割数字

**没有自动强制类型转换**：Rust 是静态类型语言，但是不像 Java 没有自动的强制类型转换。也就是说，以下的操作是不被编译器所接受的：

```rust
let b: u8 = 100;
let a: u32 = b;
// 由于没有自动的强制类型转换，所以无法将 u8 类型的变量 b 赋值给 u32 类型的 a
```

### 2. 变量 Variables

在 rust 中使用 let 关键字声明变量。可以使用如下的语法，指明变量类型和值：

```rust
// let <variable_name>: <type> = <expression>;
let x: u32 = 42;
```

如果没有明确指明变量的类型，编译器会基于上下文尝试推断变量的类型：

```rust
let x = 42;
let y: u32 = x;
// 这里的 x 在下文中被赋值给 y，所以这里的 x 就不是默认的 i32 类型了，而是 u32
```

**函数的参数也是变量**：并不是所有的变量都是由 let 声明，函数的参数也是变量：

```rust
fn add_one(x: u32) -> u32 {
    x + 1
}
// 这里的 x 是一个 u32 类型的变量
```

变量在使用之前必须初始化。

**mut 关键字：**

在 Rust 中，变量默认赋值后是不能修改的，如果想要变量是可以修改的，则需要使用到 mut 关键字：

```rust
// `sum` and `i` are mutable now!
let mut sum = 0;
let mut i = 1;

while i <= 5 {
    sum += i;
    i += 1;
}
// i 如果是在 for 中是可以进行 mut 声明的
```



### 3. 分支语法（if/else）

**在 Rust 中 if 语句 不是语句而是表达式，是有返回值的！**语法示例：

```rust
let number = 3;
let message = if number < 5 {
    "smaller than 5"
} else {
    "greater than or equal to 5"
};
```

### 4. panic! 宏

当出现一些错误的时候，可以调用panic！直接终止程序执行。

```rust
fn main() {
    panic!("This is a panic!");
    // The line below will never be executed
    let x = 1 + 2;
}
```

### 5. 循环语句（while/for）

while 语法/ for 语法：

``` rust
while <condition> {
    // code to execute
}

for <element> in <iterator> {
    // code to execute
}
// 其中的 element/condition 和 if 一样 是不用括号的
```

Rust 中范围有一下几种形式：

- `1..5`: 半开区间，不包括 5
- `1..=5`: 闭区间，包括 5
- `1..`: 表示 从 1 到 无穷大的数字
- `..5`: 从最小值到 4
- `..=5`: 从最小值到 5

> 针对溢出，Rust 有两种形式：overflow-checks
>
> - 溢出检查设置为 true，则在溢出时会 panic
>
> - 溢出检查设置为 false，则会溢出包装，也就是整个值域是一个环，会溢出到最前面
>
> Rust 有两种环境，一个是 dev 开发环境，一个是 release 发布环境，dev 默认 overflow-check 为 true， release 默认为 false，可以在 Cargo 配置文件中修改 profile 选项
>
> **`saturating_ methods`**：可以限制溢出，锁定在边界值，不过在使用这个方法时要指明变量类型

**`as`关键字**：可以使用 `as`运算符进行 integer 之间的类型转换，这种转换是健壮的，在向下转换时会进行截断。

```rust
// A number that's too big 
// to fit into a `u8`
let a: u16 = 255 + 1;
let b = a as u8;
// 这里的 b 会是 0
```

> 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0
>|                       |                        |
>+---------------+---------------+
>  First 8 bits          Last 8 bits

## 二、所有权 ownership

### 1. 结构体（struct）

在 Rust 中 结构体和其他语言的类或者对象很像，都是将一些数据联合成一个实体。

**结构体定义**：其大致定义如下所示

```rust
struct Configuration {
   version: u32,
   active: bool
}
// 逗号分隔属性，冒号分隔名称和类型

struct Ticket {
    title: String,
    description: String,
    status: String
}
```

**示例化**：可以通过指明每一个属性的值来创建一个结构体的实例

```rust
// Syntax: <StructName> { <field_name>: <value>, ... }
let ticket = Ticket {
    title: "Build a ticket system".into(),
    description: "Create a system that can manage tickets across a Kanban board".into(),
    status: "Open".into()
};

```

**调用实例属性**：通过 `.`操作符来调用实例的属性

**方法定义**：需要在一个 impl 域内声明和实现，才会将方法和结构体绑定

```rust
impl Ticket {
    fn is_open(self) -> bool {
        self.status == "Open"
    }
}

// Syntax:
// impl <StructName> {
//    fn <method_name>(<parameters>) -> <return_type> {
//        // Method body
//    }
// }

```

方法和函数十分相似，主要有两点不同：

- 方法 methods 需要定义在 impl 域里面
- 方法可能会将 `self` 作为第一个参数。`self` 是一个关键字，代表着正调用这个方法的结构体的实例

> 如果一个方法将 self 作为它的第一个参数，那么它可以使用如下的调用语法
>
> ```rust
> // Method call syntax: <instance>.<method_name>(<parameters>)
> let is_open = ticket.is_open();
> ```
>
> 

**静态方法**：如果一个方法没有将 `self` 作为它的第一个参数，那么这个方法就是一个静态方法。静态方法的调用语法和普通方法不一样。

```rust
// Function call syntax: <StructName>::<method_name>(<instance>, <parameters>)
let is_open = Ticket::is_open(ticket);
```

### 2. 模块 （Modules）

Rust 中一个模块就是：一些相关性大的代码组合起的同一个命名空间。在 java 中，一个文件就类似一个模块。下面是一个模块的示例：

```rust
#[cfg(test)]
mod tests {
    // [...]
}
```

**内联模块**：上面的 test 就是一个内联模块，模块的声明（mod tests）和模块的内容（{...}）彼此相邻。

**模块树**：模块是可以嵌入的，通过一个树结构。模块树的根就是 crate，这是在所有模块之上的最高模块。对于一个 library，根模块一般就是`src/lib.rs`。

**外部模块和文件系统**：内联模块对于小片的代码是有用的，但是当项目过于庞大，导致你想要把他们分割成多个文件时，你可以先声明子模块的存在，通过 `mod`关键字。

> Cargo：Rust 的包管理工具，可以通过包含的模块找到实现的文件
>
> 如果模块声明在 root crate，cargo 期望文件应该命名为：
>
> - `src/<module_name>.rs`
> - `src/<module_name>/mod.rs`
>
> 如果模块是其他模块的子模块，文件应该被命名为：
>
> - `[..]/<parent_module>/<module_name>.rs`
> - `[..]/<parent_module>/<module_name>/mod.rs`
>
> 例如：`src/animals/dog.rs` 或者 `src/animals/dog/mod.rs`，其中 dog 是 animal 的子模块。

**use 关键字和 item 路径**：可以在同一个模块内直接访问数据项而不需要任何的特殊语法，只需要使用名字：

```rust
struct Ticket {
    // [...]
}

// No need to qualify `Ticket` in any way here
// because we're in the same module
fn mark_ticket_as_done(ticket: Ticket) {
    // [...]
}
```

但是在不同的模块之间这样的做法是行不通的，需要通过路径来访问想要获得的实体数据项。可以组合不同的路径 path：

- 从 crate 模块开始：`crate::module_1::module_2::MyStruct`
- 从父模块开始：`super::my_function`
- 从最近的模块开始：`sub_module_1::MyStruct`

可以使用 use 关键字将路径中的数据项直接导入到当前域内，这样就不用那么长的前缀了：

```rust
// Bring `MyStruct` into scope
use crate::module_1::module_2::MyStruct;

// Now you can refer to `MyStruct` directly
fn a_function(s: MyStruct) {
     // [...]
}
```

同时如果想导入多个，可以直接使用 *。