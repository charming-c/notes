# 八皇后问题

## 【问题】

在一个 8 * 8 的棋盘上摆放 8 个皇后，使其不能互相攻击，即任意两个皇后不能处在同一行、同一列、同一对角线上。同时，可以把问题扩展到 n 皇后问题。

想法：

棋盘的任意一行都可以并且只能摆放一个皇后，所有 n 皇后问题的可能解用一个 n 元向量就可以表示，即第 i 个皇后 摆在第 x[i] 列，这样就直接规避了都个皇后处于一行的情况，默认第 i 个皇后在第 i 行，同时由于问题的约束条件可以知道 对于任意的 i j 个皇后，x[i] != x[j] && x[i] - x[j] != i - j。

## 【解法】 -- 回溯算法

1. 用一个大小为 n 的数组来存储第 k 个皇后所在的列，且初值赋值为-1，方便后续在进行摆放时遍历所有列
2. 用一个循环，依次摆放各个皇后的位置
   1. 先从k = 0，第一个皇后开始摆放位置，首先尝试第一列 x[k]++
   2. 循环判断是否合理，即x[k] < n && 与k 之前的元素不冲突
      1. 若不合理，则要尝试下一列 x[k]++ (注意当x[k] == n时，表示到第 n 列的皇后都有找到合适的位置，则之后要进行回溯处理)
   3. 判断是否将所有的皇后都摆放完了 即 k == n-1且 x[k] < n:
      1. 是，则输出 x[n]，打印出答案
   4. 判断在摆放完k个后，x[k]的列，
      1. 如果x[k]  < n，说明皇后位置摆放正常，则进行摆放下一个 k++
      2. 否则就是当前的皇后在试了所有的列以后都无法摆放正确，则只能回溯，重新摆放前一个（k-1）个皇后的位置，注意这个时候x[k-1]本身的值就是上一次摆放的列，我们不需要更新，只需要试探下一个列就可以，但是对于第k个皇后，由于x[k]已经溢出棋盘，所以要重置x[k--] = -1

代码：

```c
#include<iostream>

using namespace std;

int x[8] = {-1,-1,-1,-1,-1,-1,-1,-1};

int Place(int k){
    for(int i = 0; i<k; i++){
        if(x[i] == x[k] || abs(i-k) == abs(x[i] - x[k]))
            return 1;
    }
    return 0;
}


void Queen(int n){

    int count = 0;
    int k = 0;
    while(k >= 0){
        x[k]++;
        while(x[k] < n && Place(k) == 1)
            x[k]++;
        if(x[k]<n && k == n-1){
            for(int i = 0; i<n; i++){
                cout<<x[i] + 1<< " ";
            }
            cout<<endl;
            count++;
        }
        if(x[k] < n && k < n-1)
            k = k + 1;
        else
            x[k--] = -1;
    }
    cout<<count<<endl;
}


int main(){
    Queen(8);
    return 0;
}
```

