# 0/1 背包问题

## 【问题】

给定 n 个重量为{ w1, w2, ... , wn}、价值为{v1, v2, v3, ... , vn}的物品和一个容量为 C 的背包， 0/1背包问题就是求这些物品中的最有价值的子集，并且要能够装到背包中。

## 1. 暴力法

考虑给定的 n 个物品集合的所有子集，找出所有总重量不超过背包容量的子集，计算每个可能的子集的总价值，然后找到价值最大的子集。对于每一个物品，都有添加到背包和不添加到背包两种选择，所以对于一个有 n 个物品的背包问题，他的子集数量是 2^n 个，所以暴力法的时间复杂度应该是 o（2^n) , 而这个方法的难点几乎没有，就是生成一个子集集合。

## 2. 回溯法

依据回溯法的原理，找到问题的解空间树，易知是一颗子集树，可以将每个物品的选择最为一个节点，选择进入左子树，不选则进入右子树，深度优先搜索，同时在搜索的过程中要维护一下本身背包空余的容量,和当前做选择的位置，这样方便剪枝和回溯。

```c
#include<stdio.h>
#include<cmath>
#define MAX(a,b) (((a)>(b))?(a):(b))

int W = 10;
int value[] = {6,3,5,4,6};
int weight[] = {2,2,6,5,4};
int n = 5;

int maxValue(int w, int v, int pos){

    // 剪枝
    if( pos >= n || w < weight[pos])
    return v;

    // 搜索到最底层
    int v1 = maxValue(w - weight[pos], v + value[pos], pos + 1);

    // 回溯
    int v2 = maxValue(w , v, pos + 1);

    // 寻找最优解
    return MAX(v1,v2);
}

int main(){
    printf("%d\n",maxValue(10,0,0));
    return 0;
}
```

这是自己写的，依据递归树理解的回溯算法

## 3. 动态规划

0/1背包问题其实是非常经典的动态规划问题，许多教材都拿0/1背包作为动态规划的入门算法示例讲解。首先思考，0/1背包问题的重叠子问题，最优性原理、多阶段决策的内容到底在哪里？

### 1. 重叠子问题

从上面的回溯就不难看出，当前位置的物品我们如果做了决策，放入背包或者不放入，倘若背包容量足够的话，那么后面的若干个物品的决策是可以相同的，但对于回溯来说，都要重新计算一遍，这样就造成子问题的重复了。

### 2. 最优性原理

这个在哪里体现呢，就是对于当前一定容量的背包，我能找到的最优解就是 1. 选择将当前的物品放入背包，并去求得背包容量减去物品重量的剩余容量里能够得到的最大的价值，这样这就是一个背包容量缩小的子问题了，2. 选择不放入背包，背包能承载的最大价值可以承接自比自己容量小一点的背包。然后在这两个价值里选择更优的的那个，问题就解决了。其实想到这里，动态规划的状态转移方程也已经出来了，如果用w[j]表示容量为j的背包的最大价值的话，在第i个物品的位置，我们可以知道w[j] = max(w[j-1],w[j-weight[i]] + v[i])

### 3. 多阶段决策

动态规划是一个从底向上的算法，当物品只有一个时，可以直接求得各个容量不大于C的背包的最大价值，而当有两个物品时，就可以对第二个物品做决策，并且依赖于只有一个物品时就解出的最优解

填表：

|      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| 1    | 0    | 0    | 6    | 6    | 6    | 6    | 6    | 6    | 6    | 6    | 6    |
| 2    | 0    | 0    | 6    | 6    | 9    | 9    | 9    | 9    | 9    | 9    | 9    |
| 3    | 0    | 0    | 6    | 6    | 9    | 9    | 9    | 9    | 11   | 11   | 14   |
| 4    | 0    | 0    | 6    | 6    | 9    | 9    | 9    | 10   | 11   | 13   | 14   |
| 5    | 0    | 0    | 6    | 6    | 9    | 9    | 9    | 12   | 12   | 15   | 15   |

代码：

```c
#include<stdio.h>
#include<math.h>

int knapStak(int value[], int weight[], int n, int range){
    int dp[n+1][range+1];
    for(int i = 0; i<=range; i++){
        dp[0][i] = 0;
    }
    for(int i = 0; i<=n; i++){
        dp[i][0] = 0;
    }
    // 这里是比较经典的状态转移方程
    for(int i = 1; i<=n; i++){
        for(int j = 1; j<=range; j++){
            // 当前这个物品的重量比背包最大的容量还要大的时候，不取当前物品，最大价值承接自上一个物品能获得的最大价值
            if(weight[i - 1] > j) dp[i][j] = dp[i-1][j];
            else{
                // 当前物品是可以放入背包的，这时就要进行决策，
                // 有两种选择： 
                // 1. 不放入背包，承接上一个物品的最大价值
                // 2，放入背包，此时要回溯到前一个位置的容量减去本物品质量的价值 再加上本物品价值就可以了
                dp[i][j] = fmax(dp[i-1][j], dp[i-1][j-weight[i - 1]] + value[i - 1]);
            }
        }
    }

    for(int i = 0; i<=n; i++){
        for(int j = 0; j<=range; j++){
            printf("%d\t",dp[i][j]);
        }
        printf("\n");
    }

    return dp[n][range];
}

int main(){
    int value[] = {6,3,5,4,6};
    int weight[] = {2,2,6,5,4};
    int n = 5;
    int range = 10;
    printf("%d\n",knapStak(value,weight,n,range));
    return 0;
}
```

