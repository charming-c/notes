# 异常控制流（ECF）

## 一、 异常

在操作系统启动时，会分配和初始化一张称为**异常表**的跳转表，每一个表目包含一个异常处理程序的地址。

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20231012173551591.png" alt="image-20231012173551591" style="zoom:50%;" />

异常表的起始地址放在一个叫做**异常表基址寄存器**的特殊 CPU 寄存器中。异常类似于过程调用（函数调用），但也有不同之处：

- 过程调用时，再跳转到处理程序之前，处理器将返回地址压入栈中。但是，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条指令（如果时间不发生，将会在当前指令后执行的指令）
- 处理器还会把一些额外的状态压到栈中，在处理程序返回时，重新开始执行被中断的程序会需要这些状态
- 如果控制从用户程序转移到内核，所有的项目都会被压倒内核栈中，而不是用户栈
- 异常处理程序运行在**内核模式**下，此时对系统的所有资源都有完全的访问权限

在处理程序处理完事件以后，通过执行一条特殊的“从中断返回”指令，可选的返回到被中断的程序

### 1. 异常的种类

| 类别 |        原因        | 异步/同步 |       返回行为       |
| :--: | :----------------: | :-------: | :------------------: |
| 中断 | 来自I/O设备的信号  |   异步    | 总是返回到下一条指令 |
| 陷阱 |     有意的异常     |   同步    | 总是返回到下一条指令 |
| 故障 | 潜在的可恢复的错误 |   同步    | 可能返回到当前的指令 |
| 终止 |   不可恢复的错误   |   同步    |       不会返回       |

- 硬件中断不是由任何一条专门的指令造成的，其处理程序被称为**中断处理程序**
- 陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做**系统调用**
- 故障由错误情况引起，如能够修正，返回重新执行，不能则会返回到内核中的 abort 例程，这时会终止引起故障的程序
- 终止是不可恢复的致命错误造成的结果

c语言程序用 syscall 函数可以直接调用任何系统调用。同时，标准 C 库将大多数系统调用包装，这些包装函数将参数打包到一起，以适当的系统调用指令陷入内核，然后将系统调用的返回状态传递回调用程序。

> 在 x86-64 系统上，系统调用是通过一条称为 syscall 的陷阱指令来提供的。所有到 Linux 系统调用的参数都是通过通用寄存器而不是栈传递的，寄存器 %rax 包含系统调用号，寄存器 %rdi、%rsi、%rdx、%r10、%r8、%r9 包含最多 6 个参数。从系统调用返回时， %rcx 和 %11 都会被破坏，%rax 包含返回值

## 二、进程

进程的经典定义就是**一个执行中程序的实例**，操作系统实现进程的细节之后学习。进程提供给应用程序两个关键抽象：

- 一个独立的逻辑控制流，它提供一个假象：程序独占地使用处理器
- 一个私有的地址空间，它提供一个假象：程序独占地使用内存系统

### 1. 逻辑控制流

进程给每个程序提供的独占处理器的假象，如果用调试器单步执行程序，会看到一系列程序计数器的值，这个 PC 值的序列就是逻辑控制流。

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20231013151243427.png" alt="image-20231013151243427" style="zoom:50%;" />

### 2. 私有地址空间

进程为每个程序提供自己的**私有地址空间**，一般来说，这个空间中某个地址相关联的内存字节是不能被其他进程读和写的。尽管和每个私有地址空间相关联的内存的内容不一样，但结构是通用的。

地址空间底部是保留给用户程序的，包括通常的代码、数据、堆和栈段。代码段总是从地址 0x400000 开始。地址空间顶部保留给内核（操作系统内存中常驻的部分），这部分包含内核在代表进程执行指令时（比如当应用程序执行系统调用时）使用的代码、数据和栈。

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20231013152406944.png" alt="image-20231013152406944" style="zoom:50%;" />

### 3. 上下文切换

操作系统内核使用一种称为**上下文切换**的较高层形式的异常控制流来实现多任务。内核为每个进程维持一个上下文。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈、和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程，这种决策叫**调度**。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种**上下文切换**的机制来讲控制转移到新的进程。

当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个时间发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比如，一个 read 系统调用需要访问磁盘，内核可以选择执行上下文切换，运行另外一个进程，而不是等待数据从磁盘到达。

中断也可能引发上下文切换。比如所有系统都有某种产生周期性定时器中断的机制，通常为 1ms 或 10ms，每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，，并切换一个新的进程。

如图展示了一对进程 A 和 B 之间上下文切换的示例。进程 A 初始运行在用户模式中，直到通过执行系统调用 read 陷入到内核，内核中的陷阱处理程序请求来自磁盘控制器的 DMA 传输，并且安排在磁盘控制器完成从磁盘到内存的数据传输后，磁盘中断处理器。

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20231013155728431.png" alt="image-20231013155728431" style="zoom:50%;" />

## 三、进程控制

### 1. 获取进程 ID

每个进程都有一个唯一的正数（非零）进程 ID（PID）。getpid 和 getppid 函数返回一个类型为 pid_t 的整数值，在 Linux 系统上它在 types.h 被定义为 int。

```c
pid_t getpid(void)
pid_t getppid(void)
```

### 2. 创建和终止进程

从程序员的角度，可以认为进程总是处在下面三种状态之一：

- 运行。要么进程在 CPU 上执行，要么在等待被执行且最终会被内核调度。
- 停止。进程的执行被挂起，且不会被调度。
- 终止。进程永远的停止了。进程会因为三种原因停止，1）收到一个信号，该信号的默认行为是终止进程，2）从主程序返回，3）调用 exit 函数。

```c
void exit(int status)
pid_t fork(void)		//子进程返回0，父进程返回子进程的 PID，如果出错，则为-1
```

父进程通过 fork 函数创建一个新运行的子进程。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同但是独立的一份副本，包括代码、数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用 fork 时， 子进程可以读写父进程中打开的任何文件。

fork 函数是有趣的，因为它只会被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork 返回子进程的 PID。在子进程中， fork 返回 0，因为子进程的 PID 总是为正数，返回值就提供了一个明确的方法来分辨程序是在父进程还是在子进程中执行。

### 3. 回收子进程

当一个进程由于某种原因终止，内核并不是立即把他从系统中清除，相反，进程被保持在一种已终止的状态中，直到被其父进程回收。一个终止了还没有被回收的进程称为**僵死进程**。如果一个父进程终止了，内核会安排 init 进程成为他的孤儿进程的养父。 Init 进程的 PID 为 1，是在系统启动时由内核创建，它不会终止，是所有进程的祖先，如果父进程没有回收他的子进程就终止了， init 进程会去回收他们。

一个进程可以通过调用 **waitpid 函数**来等待他的子进程终止或停止。

``` c
// 返回：如果成功，则为子进程的 PID，如果 WNOHANG，则为 0，如果其他错误，则为 -1
pid_t waitpid(pid_t pid, int *statusp, int options);
```

> 在默认情况下（当 options = 0），waitpid 挂起调用进程的执行，直到它的等待集合中的一个子进程终止。如果等待集合中的一个进程在调用时就已经终止，那么就立即返回。在这两种情况中，函数返回已终止的进程的 PID。此时已终止的子进程已经被回收，内核会删除所有痕迹。
>
> 1. 判定等待集合的成员
>
>     等待集合的成员是由参数 pid 确定的：
>
>     - pid > 0，那么等待集合就是一个单独的子进程，它的进程 ID 等于 pid。
>     - pid = -1，那么等待集合就是由父进程所有子进程所组成。
>
>     还支持进程组，在此不解释
>
> 2. 修改默认行为
>
>     默认的行为是挂起调用进程，直到有子进程终止。可以通过将 options 设置为常量 WNOHANG、WUNTRACED、WCONTINUE 的各种组合来修改默认行为：
>
>     - WNOHANG：如果等待集合中的任何子进程都没有终止，那么就立即返回（返回值为 0）。在等待子进程终止的同时，如果还想做有用的工作，这个选项会有用。
>     - WUNTRACED：挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。当想要检查已终止或被停止的进程时，此选项可用。
>     - WCONTINUED：挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到 SIGCONT 信号重新开始执行。
>
>     可以将这些组合起来。
>
> 3. 检查已回收子进程的退出状态
>
>     如果 statusp 参数非空，那么 waitpid 就会在 status 中放上关于导致返回的子进程的状态信息，status 是 statusp指向的值。通过调用以下几个宏，来判断检查子进程退出的状态：
>
>     - WIFEXITED(status)：如果子进程通过调用 exit 或者一个返回（return）正常终止，返回真。
>     - WEXITSTATUS(status)：返回一个正常终止的子进程的退出状态。只有在 WIFEXITED() 返回为真时，才会定义这个状态。
>     - WIFSIGNALED(status)：如果子进程是因为一个未被捕获的信号终止的，那么就返回真。
>     - WTERMSIG(status)：返回导致进程终止的信号的编号。只有在 WIFSIGNALED() 返回为真时，才定义这个状态。
>     - WIFSTOPPED(status)：如果引起返回的子进程当前是停止的，那么就会返回真。
>     - WSTOPSIG(status)：返回引起进程停止的信号的编号。只有在 WIFSTOPPED() 返回为真时，才定这个这个状态。
>     - WIFCONTINUED(status)：如果子进程收到 SIGCONT 信号重新启动，则返回真。
>
> 4. 错误条件
>
>     如果调用进程没有子进程，那么返回 waitpid 返回 -1，并且设置 errno 为 ECHILD。如果 waitpid 函数被一个信号中断， 那么它返回 -1，并设置 errno 为 EINTR。

**wait 函数** 是 waitpid 函数的简单版本

```c
pid_t wait(int *statusp);
```

等价于 waitpid（-1， statusp， 0）

### 4. 让进程休眠

- **sleep 函数**将一个进程挂起一段指定的时间

    ```c
    unsigned int sleep(unsigned int secs);
    // 返回还要休眠的秒数
    ```

- **pause 函数**让调用函数休眠，直至该进程收到一个信号

    ```c
    int pause(void)
    // 总是返回 -1
    ```

### 5. 加载并运行程序

- **execve 函数**在当前进程的上下文中加载并运行一个程序

    ```c
    int execve(const char *filename, const char *argv[], const char *envp[]);
    // 如果成功，则不返回，如果错误，则返回 -1
    ```

execve 函数加载并运行可执行目标文件，且带参数列表 argv 和环境变量列表 envp。只有当出现错误时，例如找不到 filename，execve 才会返回到调用程序。所以，与 fork 一次调用返回两次不同，execve调用一次并从不返回。

1. 参数列表时如图所示的数据结构表示的。argv 变量指向一个以 null 结尾的指针数组，其中每个指针都指向一个参数字符串。按照惯例，argv[0] 是可执行目标文件的名字。环境变量的列表是由一个类似数据结构表示的，如图所示，envp变量指向一个以 null 结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如“name=value”的名字-值对。

    <img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20231013214923862.png" alt="image-20231013214923862" style="zoom:50%;" />

2. 在 execve 加载了 filename 之后，调用启动代码，将控制传递给新程序的主函数，该主函数有如下形式的原型：`int main(int argc, char **argv, char **envp)` 其中 argc 给出 argv[] 数组中非空指针的数量。

3. 当 main 开始执行，用户栈的组织结构如图所示。从栈底往栈顶看，首先是参数和环境字符串。栈往上紧随其后是以 null 结尾的指针数组，其中每个指针都指向栈中的一个环境变量字符串。全局变量 environ 指向这些指针中的第一个 envp[0]。紧随环境变量数组之后的是以 null 结尾的 argv[] 指针数组，其中每个元素指向栈中的一个参数字符串。在栈的顶部是系统启动函数 libc_start_main的**栈帧**（函数在被调用时，所拥有的一块独立的用于存放函数所使用的状态和变量的栈空间）。

    <img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20231013220732900.png" alt="image-20231013220732900" style="zoom:50%;" />

- **getenv 函数**在环境数组中搜索字符串“name=value”。如果找到了，它就返回一个指向 value 的指针，否则它就返回 null。

    ```c
    char *getenv(const char *name)
    // 若存在则为指向 name 的指针，若无匹配的，则为 null
    ```

- 如果环境数组包含形如“name=oldvalue”的字符串，那么 unsetenv 会删除它，而 setenv 会用 newvalue 代替 oldvalue， 但是只在 overwrite 非零时才会这样。如果 name 不存在，那么 setenv 就把“name=newvalue”添加到数组中。

    ```c
    int setenv(const char *name, const char *newvalue, int overwrite);
    // 返回：若成功则为 0，若错误则为 -1。
    void unsetenv(const char *name)
    // 返回：无
    ```

> 程序和进程的区别
>
> - 程序是一堆代码和数据，程序可以作为目标文件存在于磁盘上，或者是作为段存在于地址空间中。
> - 进程是执行中程序的一个实例。
> - 程序总是运行在某个进程的上下文中

> fork 和 execve 区别
>
> - fork 函数在新的子进程中运行相同的程序，新的子进程是父进程的复制品。
> - execve 函数在当前进程的上下文中加载并运行一个新的程序，会覆盖当前进程的地址空间，但并没有创建新的进程。新的程序有相同的 PID，并且继承了调用 execve 函数时已打开的所有文件描述符。

## 四、信号

一个**信号**就是一条消息，它通知进程系统中发生了一个某种类型的事件。底层的硬件异常是由内核异常处理程序处理的，正常情况下对用户是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20231015173150087.png" alt="image-20231015173150087" style="zoom:50%;" />

传送一个信号到目的进程是由两个不同的步骤组成的

1. **发送信号**：内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送信号通常有两个如下原因：

    1. 内核监测到一个系统事件，比如除零错误或者子进程终止
    2. 一个进程调用了 kill 函数，显式地要求内核发送一个信号给目的进程。

    一个进程可以发送信号给他自己。

2. **接收信号**：当目的进程被内核强迫以某种方式对信号的发送作出反应，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序的用户层函数捕获这个信号。

    <img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20231015174906923.png" alt="image-20231015174906923" style="zoom:50%;" />

一个发出但是没有被接收的信号叫做**待处理信号**。

- 在任何时刻，一种类型，至多只会有一个待处理信号。

- 假如一个进程有一个类型为 k的 待处理信号，那么任何接下来发送这个进程的类型为 k 的信号都不会排队等待，它们只是被简单的丢弃。
- 一个进程可以有选择性的阻塞接收某种信号，一种信号被阻塞时，仍可以被发送但不会被接收。

- 一个待处理信号最多只会被接收一次。内核为每个进程在 pending 位向量中维护者待处理信号的集合，在 blocked 位向量里面维护着被阻塞信号的集合。

### 1. 发送信号

**进程组**：每个进程都属于一个进程组，进程组是由一个正整数进程组 ID 来标识。**getpgrp函数**返回当前进程的进程组 ID：

```c
pid_t getpgrp(void);
// 返回：调用进程的进程组 ID
```

默认一个子进程和它的父进程同属于一个进程组。一个进程可以通过使用 **setpgid函数**来改变自己或者其他进程的进程组：

```c
int setpgid(pid_t pid, pid_t pgid)
// 返回：若成功则为0，若错误则为-1
```

**setpgrp 函数**将进程 pid 的进程组改为 pgid。如果 pid 为 0，那么就使用当前进程的 PID。如果 pgid 是 0，那么就调用 pid 指定的进程的 PID 作为进程组 ID。

#### 1. 用 /bin/kill 程序发送信号

/bin/kill 程序可以向另外的进程发送任意的信号。

>linux> /bin/kill -9 15213
>
>发送信号 9（SIGKILL）给进程 15213

一个为负的 PID 会导致信号被发送到进程组 PID 中的每一个进程。

> linux > /bin/kill -9 -15213
>
> 发送一个 SIGKILL 信号给进程组 15213 中的每个进程。

#### 2. 用键盘发送信号

Unix shell 使用作业这个抽象概念来表示为对一条命令行求值而创建的进程。在任何时刻，至多只有一个前台作业和 0 个或多个后台作业。比如，键入

> linux> ls |sort

会创建一个由两个进程组成的前台作业，这两个进程是通过 Unix 管道连接的：一个进程会运行 ls 程序，另一个运行 sort 程序。shell 为每个作业创立一个独立的进程组。进程组 ID 通常取自作业中父进程中的一个。

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20231015215746927.png" alt="image-20231015215746927" style="zoom:50%;" />

在键盘上输入 Ctrl + C 会导致内核发送一个 SIGINT 信号到**前台进程组中的每个进程**。默认情况下，结果是终止前台作业。类似的，输入 Ctrl + Z 会发送一个 SIGTSTP 信号到前台进程组中的每个进程。默认情况下，结果是停止（挂起）前台作业。

#### 3. 用 kill 函数发送信号

进程通过调用 kill 函数发送信号给其他进程（包括他们自己）。

```c
int kill(pid_t pid, int sig);
// 返回：若成功则为 0，若错误则为 -1。
```

如果 pid 大于 0，那么 kill 函数发送信号号码 sig 给进程 pid。如果 pid 等于 0，那么 kill 发送信号 sig 给**调用进程所在进程组中的每个进程**，包括调用进程自己。如果 pid 小于 0，kill 发送信号 sig 给进程组 ｜pid｜（pid 的绝对值）中的每个进程。

#### 4. 用 alarm 函数发送信号

进程可以使用 **alarm 函数**向它自己发送 SIGALRM 信号。

```c
unsigned int alarm(unsigned int secs)
// 返回：前一次闹钟剩余的秒数，若以前没有设定闹钟，则为 0。
```

alarm 函数安排内核在 secs 秒后发送一个 SIGALRM 信号给调用进程。如果 secs 是 0，那么不会调度安排新的闹钟。在任何情况下，对 alarm 的调用都将取消任何待处理的闹钟，并且返回任何待处理的闹钟在被发送前还剩下的秒数。若没有待处理的闹钟，就返回 0。

### 2. 接收信号

当内核把进程 p 从内核模式切换到用户模式时（例如，从系统调用返回或者是完成了一次上下文切换），它会检查进程 p 的未被阻塞的待处理信号的集合。如果该集合非空，那么内核会选择集合中的某个信号 k（通常是最小的 k），并且强制 p 接受信号 k。收到这个信号会触发进程采取某种行为。完成这个行为以后，控制才会传递回 p 的逻辑控制流的下一条指令。每个信号都有一个预定义的默认行为，是下面的一种：

- 进程终止
- 进程终止并转储内存
- 进程挂起知道被SIGCONT 信号重启
- 进程忽略该信号

进程可以通过 **signal函数**修改和信号相关联的默认行为，除了 SIGSTOP 和 SIGKILL。

```c
sighandler_t signal(int signum, sighandler_t handler);
// 返回：若成功则为指向前次处理程序的指针，若出错则为 SIG_ERR（不设置 errno）。
```

- 如果 handler 是 SIG_IGN，那么忽略类型为 signnum 的信号
- 如果 handler 是 SIG_DFL，那么类型为 signum 的信号行为恢复为默认行为。
- 否则，handler 就是用户定义的函数的地址，这个函数被称为信号处理程序，只要进程接收到一个类型为 signum 的信号，就会调用这个程序。通过把处理程序的地址传递到 signal 函数从而改变默认行为，叫做设置信号处理程序。

信号处理程序是可以被其他信号中断的：

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20231016015443169.png" alt="image-20231016015443169" style="zoom:50%;" />

### 3. 阻塞和解除阻塞信号

Linux 提供阻塞信号的隐式和显式的机制：

- 隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。
- 显示阻塞机制。应用程序可以使用 sigprocmask 函数和它的辅助函数，明确的阻塞和解  除阻塞选定的信号。

```c
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
int sigemptyset(sigset_t *set); // 初始化 set 为空集合
int sigfillset(sigset_t *set);	// 把每个信号添加到 set 中
int sigaddset(sigset_t *set, int signum);	// 把 signum 添加到 set
int sigdelset(sigset_t *set, int signum);	// 把 signum 从 set 中删除
// 返回：如果成功，则为 0；若出错为 -1。

int sigismember(const sigset_t *set, int signum);
// 返回：若 signum 是 set 的一员则为 1，如果不是则为 0， 出错则为 -1。
```

sigprocmask 函数改变当前阻塞的信号集合（blocked 位向量），具体的行为依赖于 how 的值：

- SIG_BLOCK：把 set 中的信号添加到 blocked 中（blocked = blocked ｜set）
- SIG_UNBLOCK：从 blocked 中删除 set 中的信号（blocked = blocked & ~set）
- SIG_SETMASK：blocked = set

如果 oldset 非空，则 blocked 位向量之前的值保存在 oldset 中。

### 4. 编写信号处理程序

信号处理是 Linux 系统编程最棘手的问题。处理程序的几个属性使得很难推理分析：

- 处理程序与主程序并发运行，共享同样的全局变量，因此可能与主程序和其他处理程序互相干扰；

- 如何以及何时接收信号的规则常常有违人的直觉；

- 不同的系统有不同的信号处理语义。

#### 1. 安全的信号处理

信号处理程序很麻烦是因为他们和主程序以及其他信号处理程序并发的运行。如果处理程序和主程序并发地访问同样的全局数据结构，那么结果可能是无法预知的，而且经常是致命的。

- G0. 处理程序要尽可能简单。例如，处理程序可能只是简单地设置全局标志并立即返回；所有与接收信号相关的处理都由主程序执行，他周期性的检查（并重置）这个标志。
- G1. 在处理程序中只调用异步信号安全的函数。异步信号安全的函数即：1. 要么是可重入的（例如只访问局部变量）2. 要么是不能被信号处理程序中断。

- G2. 保存和恢复 errno。许多 Linux 异步信号安全的函数都会在出错时设置 errno。在处理程序中调用这样的函数可能会干扰主程序中其他依赖于 errno 的部分。解决方法是在进入处理程序时把 errno 保存在一个局部变量中，在处理程序返回前恢复它。

- G3. 阻塞所有的信号，保护对共享全局数据结构的访问。如果处理程序和主程序或其他信号处理程序共享一个全局数据结构，那么访问（读或者写）该数据结构时，你的处理程序和主程序应该暂时阻塞所有的信号。这条规则的原因是从主程序访问一个数据结构 d 通常需要一系列的指令，如果指令序列被访问 d 的处理程序中断，那么信号处理程序会发现 d 的状态不一致，得到不可预知的结果。在访问 d 时暂时阻塞信号保证了程序不会中断该指令序列。

- G4. 用 volatile 声明全局变量。考虑一个处理程序和一个 main 函数，它们共享一个全局变量 g。处理程序更新 g，main 周期性读 g。对于一个优化编译器来说， main 中 g 的值看上去没有变化过，因此使用缓存在寄存器中 g 的副本来满足对 g 的每次引用是很安全的。可是，如此，main 函数可能永远都无法看到处理程序更新过的值。

    - 可以用 volatile 类型限定符来定一个变量，告诉编译器不要缓存这个变量，volatile 限定符要求编译器每次在代码中引用 g 时，都要从内存中读取 g 的值。一般来说和其他所有共享数据结构一样，应该暂时阻塞信号，保护每次对全局变量的访问。

- G5. 用 sig_atomic_t 声明标志。在常见的处理程序设计中，处理程序会写全局标志来记录收到的信号。主程序周期性来读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志，C 提供一种整型数据类型 sig_atomic_t，对它的读和写会是保证原子的，因为可以用一条指令来实现它们：

    > volatile sig_atomic_t flag;
    >
    > 因为是不可中断的，所以可以安全的读和写 sig_atomic_t 变量，而不需要暂时阻塞信号。注意，这里对原子性的保证只适用去单个的读和写，不适用于 flag++ 或者 flag += 10 这样的更新，他们可能需要更多的指令。

#### 2. 显式地等待信号

```c
int sigsuspend(const sigset_t *mask);
// 返回 -1。
```

sigsuspend 函数暂时用 mask 替换当前的阻塞集合，然后挂起该线程，直到收到一个信号，其行为要么是运行一个处理程序，要么是终止该进程。如果它的行为是终止，那么该进程不从 sigsuspend 返回就终止。如果它的行为是运行一个处理程序，那么 sigsuspend 会从处理程序返回，恢复调用是 sigsuspend 时原有的阻塞集合。

### 五、非本地跳转

C 语言提供了一种用户级异常控制流形式，称为非本地跳转，他将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。非本地跳转是通过 setjump 和 longjump 函数提供的。

```c
int setjump(jmp_buf env);
int sigsetjmp(sigjmp_buf env, int savesigs);
void longjmp(jmp_buf env, int retval);
void siglongjmp(sigjmp_buf env, int retval);

// 返回：setjmp返回 0， longjmp 从不返回
```

longjmp 函数从 env 缓冲区中恢复调用环境，然后触发一个从最近一次初始化 env 的 setjmp 调用的返回，并带有非零的返回值 retval。 setjmp 和 longjmp 之间的相互关系是迷惑的，setjmp 只被调用一次，但返回多次：一次是当第一次调用 setjmp，而调用环境保存在缓冲区 env 中时，一次是为每个相应的 longjmp 调用。另一方面，longjmp 函数被调用一次，但从不返回。

非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。如果在一个深层嵌套的函数调用中发现了一个错误情况，我们可以使用非本地跳转直接返回到一个普通的本地化的错误处理程序，而不是费力地解开调用栈。

```c
/* $begin setjmp */
#include "csapp.h"

jmp_buf buf;

int error1 = 0; 
int error2 = 1;

void foo(void), bar(void);

int main() 
{
    switch(setjmp(buf)) {
    case 0: 
	foo();
        break;
    case 1: 
	printf("Detected an error1 condition in foo\n");
        break;
    case 2: 
	printf("Detected an error2 condition in foo\n");
        break;
    default:
	printf("Unknown error condition in foo\n");
    }
    exit(0);
}

/* Deeply nested function foo */
void foo(void) 
{
    if (error1)
	longjmp(buf, 1); 
    bar();
}

void bar(void) 
{
    if (error2)
	longjmp(buf, 2); 
}
/* $end setjmp */

```

非本地跳转的另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号达到中断了的指令的位置。

### 六、操作进程的工具

Linux 系统提供了大量的监控和操作进程的有用工具

- STRACE：打印一个正在运行的程序和他的子进程调用的每个系统调用的轨迹。
- PS：列出当前系统的进程（包括僵死进程）。
- TOP：打印出关于当前进程资源使用的信息。
- PMAP：现实进程的内存映射。
- /proc：一个虚拟的文件系统，以 ASCII 文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。比如，输入“cat/proc/loadavg“，可以看到你的 Linux 系统上当前的平均负载。