# Operating system interface

如下图所示，xv6 有传统形式的内核（一个为其他正在运行的程序提供服务的特殊程序）。每一个运行的程序，叫做进程，拥有包含指令、数据和栈的内存。当进程需要内核服务时，就会发起一个系统调用（system call）。系统调用会进入内核，内核执行服务并且返回。因此，一个程序可选的在用户态和内核态之间切换执行。同时内核使用 CPU 提供的硬件保护装置确保运行在内核态的进程只能够访问其自己的内存。

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20240313103804766.png" alt="image-20240313103804766" style="zoom: 50%;" />

xv6 内核提供了 Unix 内核借口的一个子集，如下图所示：

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20240313104531845.png" alt="image-20240313104531845" style="zoom:50%;" />

本章剩下的内容会讨论多进程（processes），内存（memory），文件描述符（file decriptors），管道（pipes）和文件系统（file sysytem）。并且通过 shell 这个程序解释。通过 shell 使用系统调用来解释这些接口的设计多么巧妙和小心。shell 是一个用户级程序，不是内核的一部分，这也意味着 shell 和其他的程序并没有什么区别，很容易被替代。现代的 Unix 操作系统有各种各样的 shell 程序可以选择，每一种都有它自己的用户接口和脚本特征。xv6 shell 是 Unix Bourne shell 的一个简单实现。

## 1. 多进程和内存

在 xv6 操作系统中，一个进程包括用户空间内存（指令、数据和栈）以及仅内核可访问的每个进程私有的状态。xv6 时间共享进程（内核的一部分）：它会在等待执行的进程的集合中透明地切换 CPU 的资源。当一个进程没有在执行时，xv6 会保存它的 CPU 寄存器，在下一次执行时再回复他们。内核会给每个程序分配一个进程ID（pid）来关联。

一个进程可以通过 fork 系统调用创建一个新的进程。fork 会分配新进程和调用进程相同的内存（包括 指令和数据）。fork 会在父进程和子进程中返回共两次。父进程返回子进程 pid，子进程返回 0，出错返回 -1。参考如下代码：

```c
int pid = fork();
if(pid > 0) {
  printf("parent: child=%d\n", pid);
  pid = wait((int *) 0);
  printf("child %d is done\n", pid)
} else if(pid == 0) {
  printf("child: exiting\n");
  exit(0);
} else {
  printf("fork error\n");
}
```

系统调用 exit 会导致调用进程停止执行并且释放资源（例如：内存和打开的文件）。exit 传入一个整型的状态参数, 0 表示成功，1 表示失败。wait 系统调用返回当前进程的被杀死或者推出的子进程的 PID，并且把子进程的状态复制给传入的指针参数。如果没有调用进程的子进程退出，那么继续等待，如果调用者没有子进程，则会立即返回 -1。如果父进程不关心子进程的退出状态，可以给 wait 传入 0。

在示例程序中，输出行：

> parent: child=1234
>
> child: exiting

取决于父进程和子进程哪一个 printf 首先被调用，可能会有相反的顺序，甚至是交叉打乱的。在子进程退出后，父进程的 wait 返回，导致父进程就打印：

> parent: child 1234 is done

虽然子进程拥有和父进程相同内容的内存，但是父进程和子进程执行在不同的内存位置和寄存器中：改变其中一个进程的变量的内容不会影响另一个进程的内容。

exec 系统调用会从文件系统的文件中加载出一个新的内存镜像，然后用它替换掉调用进程的内存。这个文件必须有一个特殊的格式，也即哪一部分是指令，哪一部分是数据，并且从哪一条指令开始执行等等。xv6 使用 ELF 格式（将会在第 3 章进行详细解释）。当 exec 成功执行后，他不会返回到调用程序，相反，它开始从文件加载的指令开始执行。exec 需要两个参数，1. 可执行文件的路径名称 2. 一个字符串参数数组。

```c
char *agrv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
```

上面的片段将调用程序的内存替换为 /bin/echo 的程序并以 echo hello 这样的参数列表执行。大多数程序忽略参数数组的第一个参数，因为第一个参数大多是程序的名称，比如这里的 /bin/echo。

> 关于 exec 和 fork：
>
> 为什么 fork 和 exec 不能合并成一个系统调用呢？shell在实现I/O重定向时利用了这种分离。为了避免创建一个重复的进程，然后立即用exec替换它的浪费，操作内核通过使用虚拟内存技术(如copy-on-write)来优化fork在这种情况下的实现(参见4.6节)。

Xv6 隐式分配了大部分用户空间内存: fork分配了子进程复制父进程内存所需的内存，而 exec 分配了足够的内存来保存可执行文件。在运行时需要更多内存的进程（也许是malloc）可以调用 sbrk(n) 将其数据内存增加n字节;sbrk 返回新内存的位置。

## 2. I/O 和 文件描述符（fd）

一个文件描述符是一个小的整型数，代表着一个内核管理的对象，其他进程可以从它读或者写数据。一个进程可以通过打开一个文件、目录、设备或者创建一个管道、或者复制一个已存在的 fd 来持有一个文件描述符。为了方便，我们通常指代这个用 fd 描述的对象为 文件。文件描述符接口将文件、管道和设备的差异都抽象出来，使得他们都看起来像是字节流。输出/输出被指代为 I/O。

在内部，xv6内核使用文件描述符作为每个进程表的索引，因此每个进程都有一个从0开始的私有文件描述符空间。按照惯例，进程从文件描述符0(标准输入)读取数据，将输出写入文件描述符1(标准输出)，并将错误消息写入文件描述符2(标准错误)。read 和 wirte 系统调用通过用 fd 打开文件进行读和写字节流的操作。现在应该清楚为什么将 fork 和 exec 分开调用是有帮助的：在这两者之间，shell 有机会重定向子进程的 I/O，而不会干扰主 shell 的 I/O 设置。也可以想象一个假设的组合 forkexec 系统调用，但是使用这样一个调用进行 I/O 重定向的选项似乎很笨拙。shell 可以在调用 forkexec 之前修改自己的 I/O 设置（然后撤销这些修改）；或者 forkexec 可以将 I/O 重定向的指令作为参数传递；或者（最不吸引人的选项）每个像 cat 这样的程序都可以学会执行自己的 I/O 重定向。

> 关于文件描述符的复制
>
> fork 函数会将父进程的文件描述符表复制给子进程，同时也会复制读写文件的当前位置偏移量。两个文件描述符共享一样的位置偏移量，当且仅当他们被分离出来时是经过一系列 fork 和 dup 调用。否则就算两个文件描述符来自于同一个 open 的文件，他们的 offset 还是不一样的。

## 3. 管道（pipe）

一个 pipe 是一个小的内核缓冲区，通过一对文件描述符暴露给进程，一个用于写，一个用于读。从 pipe 的一端写数据，使得我们同样可以从另一端读出。管道（pipe）提供了一种进程间通信的方式。通过在 fork 之后，执行 exec 之前将输入输出利用管道，可以轻易实现进程间通信，如下图所示：

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20240313194844370.png" alt="image-20240313194844370" style="zoom:50%;" />

在上面的示例中，在 fork 后，父进程和子进程都拥有管道的 fd，子进程将 fd 0（此时为标准输入）关闭，采用 dup 将 p[0] (管道读的一端)复制给 fd 0，关闭管道后，调用 exec 执行 wc 程序，当 wc 的从标准输入中读数据时，也就是管道中的读数据的一端。在父进程中，关闭管道读数据的一端，往管道写数据，然后再关闭管道写的一端。

当没有数据时，管道读的一端会一直等待（wait)，直到要么数据写入，要么管道写的一端描述符关闭。在后一种情况中，read 会返回 0.就像数据文件已经读到了末尾。事实上，read 会阻塞直到没有新数据输入的可能，这也是为什么要在 exec 之前关闭管道读的一端。如果 wc 进程的任何一个 fd 指向管道写的一端，那么 wc 就永远也看不到输入数据的结束，就会一直等待。

pipe 好像和一个临时文件没有什么区别：

> echo hello world | wc

不使用管道可以写成：

> echo hello world > tmp/xyz; wc < /tmp/xyz

但是管道与临时文件相比有四大优点：

- 管道会自动清理其数据内容本身，通过文件重定向，而临时文件需要小心删除
- 管道可以传递足够长的数据流，而临时文件则要求足够的磁盘空间
- 管道支持并行执行流水线工作，但是临时文件需要一步一步来
- 如果你正在实现进程间通信，管道的阻塞读写比文件的非阻塞语义更有效。

## 4. 文件系统

xv6 文件系统提供了数据文件(包含未解释的字节数组)和目录(包含对数据文件和其他目录的命名引用)。这些目录形成一个树，从一个称为 root 的特殊目录开始。“/a/b/c”是指根目录“/”下名为 a 的目录下名为 b 的目录下名为 c 的文件或目录。不以 / 开头的路径是相对于调用进程的当前目录计算的，可以用 chdir 系统调用改变当前目录。这两个代码片段打开同一个文件(假设所有涉及的目录都存在):

>  chdir("/a");
>  chdir("b");
>  open("c", O_RDONLY);

>  open("/a/b/c", O_RDONLY);

有一些系统调用可用于创建新文件和目录：mkdir 创建新目录，用 O_CREATE 标志调用 open 创建新数据文件，mknod 创建新设备文件。Mknod 创建一个指向设备的特殊文件。与设备文件关联的是主设备号和次设备号(mknod的两个参数)，它们唯一地标识了一个内核设备。在进程稍后打开一个设备文件时，内核将读read write 系统调用转移到内核设备实现，而不是将其传递给文件系统。

文件的名称与文件本身是不同的。同一个底层文件（称为 inode）可以有多个名称(称为 link)。每个 link 都由一个目录项组成。项包含一个文件名和一个指向 inode 的引用。inode 保存了有关文件的元数据，包括文件类型(文件、目录或设备)、长度、文件内容在磁盘上的位置，以及指向该文件的链接数量。
fstat 系统调用从文件描述符所指向的 inode 检索信息。

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20240313203107426.png" alt="image-20240313203107426" style="zoom:50%;" />

link 系统调用会创建另一个指向同一个 inode 的已存在文件的文件系统名称。下面的片段创建了一个新文件，既叫做 a 也叫做 b：

```c
open("a", O_CREATE|O_WRONLY);
link("a", "b");
```

从 a 中读写和从 b 中读写是一样的。每一个 inode 都被一个唯一的 inode number 标识。通过检查 fstat的结果，可以确定 a 和 b 引用的底层内容相同：两者都会返回相同的 inode编号(ino)，而 nlink 计数设置为2。

unlink 系统调用从文件系统中删除一个名称。只有当文件的 link 计数为 0 且没有文件描述符引用它时，文件的 inode 和保存其内容的磁盘空间才会被释放。

