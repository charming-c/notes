# Traps and system calls

对于 OS，一般有三种事件会导致 CPU 将普通的指令暂停，并将控制移交给特殊的代码去处理对应的事件。

- 一种情况就是系统调用（system call）：当一个 user 程序执行 ecall 指令请求 内核 执行一些操作。
- 另一种情况是异常（exception）：一个指令（user 或者 kernel）导致了不合法的操作，例如除 0 或者使用了一个不合法的虚拟内存地址。
- 最后一种情况是中断（interrupt）：当一个 device 需要得到 CPU 关注，例如一个磁盘硬件完成了一个读写请求。

​	本书使用 trap 作为这三种情况的统一术语。通常，在 trap 发生时正在执行的代码稍后将需要恢复，并且不需要知道发生了什么特殊情况。也就是说，我们通常希望 trap 是透明的；这对于设备中断尤其重要，因为被中断的代码通常不希望发生这种中断。通常的顺序是 trap 强制将控制转移到内核；内核保存寄存器和其他状态（保存上下文），以便可以恢复执行（恢复现场）；内核执行适当的处理程序代码(例如，系统调用实现或设备驱动程序)；内核恢复保存的状态并从陷阱中返回；原始代码会从停止的地方恢复。

​	xv6 在内核处理所有的 trap，trap 不会交给 user code 处理。对于系统调用来说，在内核中处理陷阱是很自然的。这对于中断是有意义的，因为 os 的隔离要求只允许内核使用设备，而且内核是在多个进程之间共享设备的方便机制。它对异常也有意义，因为 xv6 通过杀死违规程序来响应来自用户空间的所有异常。

​	xv6 trap 处理分四个阶段进行：RISC-V CPU 采取的硬件操作，为内核 C 代码做准备的一些汇编指令，决定如何处理 trap 的 C 函数，以及系统调用或设备驱动程序服务例程。虽然三种陷阱类型之间的通用性表明内核可以用单个代码路径处理所有的 trap，但事实证明，为三种不同的情况使用单独的代码是很方便的：来自用户空间的 trap、来自内核空间的 trap 和计时器中断。处理陷阱的内核代码（汇编程序或C语言）通常称为处理程序（handler）；第一个处理程序指令通常是用汇编语言（而不是C语言）编写的，有时被称为向量（vector）。

