# Page tables 页表

页表是当前最受欢迎的方法，当 os 需要为每一个进程提供其各自私有的地址空间和内存时。页表决定了内存地址的含义，哪一部分的物理内存是能够被访问的。虚拟地址使得 xv6 能够隔离不同进程的地址空间，并且能够在单个物理内存中实现复用。页表是一种很受欢迎的设计，因为它提供了一层定位，这使得操作系统就可以可以做很多 tricks。比如映射同一段内存到不同的内存地址，保护内核和用户栈，通过把他们实现到一个没有映射的页。

## 一、硬件地址翻译（MMU）

**RISC-V 指令操作的都是虚拟地址。**RAM、物理存储都索引到物理地址空间。页表相关的硬件连接这两种不同类型的地址。xv6 使用 Sv39 RISC-V 标准，也就是说虚拟地址只有低 39 位是可用的，高 25 位不使用。Sv39 中，高 27 位之名 PTE（页表条目），每一个 PTE 拥有 44 位的 PPN（物理页号），和其他的一些标志位（xv6 是 10 位）。MMU 使用 VA（27 + 12）39 位中的 27 位从 PTE（44 + 10） 中索引 PPN（44），得到 PA（PPN 44 + offset 12）。由于偏移量是 12 位的，可知一个物理页自然就被设置成 4096 字节（内存按照字节编址）。

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20240812173424953.png" alt="image-20240812173424953" style="zoom:50%;" />

**多级页表：**

上图是单级页表的过程，要知道页表也是存储在内存中的，可以看到对于 27 位的 PTE 位置，一共需要 2 ^ 27 个 PTE，白白占用了巨大的内存空间，因此引入多级页表，这样的话，不需要为每一个虚拟地址都创建一个PTE，只需要在实现 alloc 的时候创建映射就可以了。像下面的三级页表，不同的 level，页表可创建的数量也不一样。

> L2: 最多只会有一个
>
> L1: 最多会有 512 个，因为 L2 中一共有 512 个 PPN，每一个 PPN 指向一个 Page Directory
>
> L0: 最多有 512 * 512 个，同理
>
> 又因为 L0 中有 512 个 PTE，所以最终映射的数量也是没有变的。

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20240812173807675.png" alt="image-20240812173807675" style="zoom:50%;" />

可以看到，由于页表保存在内存中，所以每次地址翻译都需要不停的内存 IO，在多级列表中有多个页表都需要 IO，这个时候为了提高时间效率，就需要添加一层 cache，也就是 TLB（translation Look-aside Buffer），TLB 保存在 MMU 中，当然 SATP、MMU 就在 CPU 里面，地址翻译直接由 CPU 委托给 MMU 执行。

**Flags 位的重要性：**

为了方便内存管理，在实现虚拟内存时，我们还要在映射时，就设置好该内存的权限，比如读写可执行等等，Flags 实现了一定的内存安全性。

**页表实现的进程隔离（SATP）：**

因为 satp 寄存器在 CPU 执行时会切换页表的值，所以，很显然不同的进程就算是一样的 VA，由于页表的不同，最终映射的 PA 也是不一样的。这里需要注意的是，每次写完 SATP，都要刷新 TLB，不然陈旧的页表缓存会导致隔离的失效。

> 注意：物理内存指的是 DRAM 中的存储单元，也就是主存。物理内存中所有字节都有一个地址，叫做物理地址 PA。指令只会使用虚拟地址，然后 MMU 会翻译成物理地址，去做操作。不想物理内存和虚拟内存地址 VA，虚拟内存不是一个物理对象，而是指一组由内核提供的抽象和机制的集合，用来管理物理内存和虚拟地址。

## 二、内核地址空间

Xv6 为每一个进程保存一个页表，描述每一个进程的用户地址空间，同时还有一个页表用来描述内核地址空间。内核配置了一组他地址空间的 layout，使得他能访问物理内存和各种硬件资源的可预见的虚拟内存地址（这些一般是主板规定的内存地址）。如下图所示：

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20240812181125712.png" alt="image-20240812181125712" style="zoom:50%;" />

qemu 模拟计算机，包含物理地址从 0x8000 0000 到 0x8640 000（xv6 中 PHYSTOP）的 RAM。同时 qemu 也模拟了其他的 IO 设备，比如磁盘接口。这些设备接口就被设定在低于 0x8000 0000 以下的物理地址中。内核可以读写这些物理空间，从而和设备进行交互。内核在使用 RAM 和其他设备的内存的时候，是使用直接映射的方式的。也就是说，对于内核来说，这些内存的虚拟地址其实就是等于物理地址。

内核也有一些虚拟地址空间不是直接映射的：

- trampoline page
- 内核栈 page，其中 guard page 防止爆栈影响其他内核内存。

## 三、应用程序地址空间

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20240814111928837.png" alt="image-20240814111928837" style="zoom:50%;" />

