# Operation System Organization

一个操作系统必须满足三个要求：多路复用、隔离、交互。本章概述了如何组织操作系统来实现这三个需求。

## 一、抽象物理资源

我们可能会有一个疑问：为什么要有操作系统呢？我们完全可以把所有的系统调用封装成一个库，然后让应用程序链接它。在这样的构思里，每个应用程序都有它自己的库定制自己的需求。应用程序能够直接和硬件资源交互，并且以对他们来说最好的方式去使用这些资源。一些嵌入式设备和实时系统的操作系统就是这么组织的。但是这种库方法的也有它的缺点。如果有不止一个应用在运行，这些应用程序都必须正常良好的运行着。例如，每一个应用程序都必须周期性的放弃 CPU 资源，以至于其他的应用程序可以运行。这样的一个合作式的时间共享式的模式在每个应用程序信任彼此且没有 bug 时是可行的。但是更加典型的情况是应用程序之间是不互信并且有 bug 的。所以人们想要一个强隔离的模式而不是共享式的模式。为了实现这种强隔离模式，可以禁止应用程序直接访问敏感的硬件资源，并且把硬件设备抽象出来。例如，Unix 应用程序与存储的交互只能通过文件系统的 open、read、write 和 close 这样的系统调用，而不是直接读和写硬盘。这为应用程序提供了路径名的便利，并允许操作系统(作为接口的实现者)管理磁盘。即使隔离不是一个问题，有意交互的程序(或者只是希望互不妨碍)也可能会发现文件系统是比直接使用磁盘更方便的抽象。

相似的，Unix 会快速地在进程之间切换 CPU 硬件资源，必要地保存和恢复寄存器状态，以至于应用程序不需要理解时间共享。这样的快速切换允许操作系统分享 CPU，即使一些应用程序正在处于无限循环。另一个例子，Unix 进程使用 exec 去创建他们的内存镜像，而不是直接与物理内训交互，这使得操作系统可以决定在内存中将进程存储在何处。如果内存是紧张的，操作系统甚至可以存储一部分进程数据到磁盘上。Exec 也为用户存储可执行项目镜像提供了文件系统的便利。Unix进程之间的许多交互形式都是通过文件描述符实现的。文件描述符不仅抽象了许多细节(例如，管道或文件中的数据存储在哪里)，而且还以简化交互的方式定义了它们。例如，如果管道中的一个应用程序失败，内核会为管道中的下一个进程生成文件结束信号。

## 二、用户模式、管理者模式和系统调用

强隔离要求应用程序和操作系统之间有一个硬边界。如果程序出错，我们不希望操作系统或者其他的应用程序崩溃。相反，操作系统应该能够清除失败的程序，并且继续运行其他的程序。为了实现这种强隔离，操作系统必须使得应用程序不能修改（甚至读取）操作系统的数据结构和指令，并且程序不能访问其他进程的内存。CPU 为这种强隔离提供提供硬件支持，例如，RISC-V有三种CPU执行指令的模式:机器模式、管理者模式和用户模式。在机器模式下执行的指令具有完全特权;CPU以机器模式启动。机器模式主要用于配置计算机。Xv6在机器模式下执行几行代码，然后切换到管理者模式。在管理者模式下，CPU被允许执行特权指令:例如，启用和禁用中断，读取和写入保存页表地址的寄存器，等等。如果用户模式下的应用程序试图执行特权指令，则CPU不会执行该指令，而是切换到管理者模式，以便管理者模式代码可以终止应用程序，因为它做了一些不应该做的事情。应用程序只能执行用户模式指令(例如，数值加法等)，被称为在用户空间中运行，而处于管理者模式的软件也可以执行特权指令，被称为在内核空间中运行。在内核空间(或在管理者模式下)运行的软件称为内核。

一个想要调用内核函数的应用程序(例如，在xv6中读取系统调用)必须转换到内核;应用程序不能直接调用内核函数。CPU提供一个特殊的指令，将CPU从用户模式切换到管理者模式，并在内核指定的入口点进入内核。(RISC-V为此目的提供了调用指令。)一旦CPU切换到管理者模式，内核就可以验证系统调用的参数(例如，检查传递给系统调用的地址是否属于应用程序内存的一部分)，决定是否允许应用程序执行请求的操作(例如，检查是否允许应用程序写入指定的文件)，然后拒绝它或执行它。重要的是，内核控制过渡到管理者模式的入口点;如果应用程序可以决定内核入口点，那么恶意应用程序也可以，例如，在跳过参数验证的点进入内核。

## 三、内核组织方式

一个关键的问题就是操作系统的哪一部分应该在管理者模式中运行。一种可行的方案就是整个操作系统都常驻在内核中，这样所有系统调用的实现都会在管理者模型中运行。这种组织模式被称为：单体内核。

**单体内核：**

在这种组织中，整个操作系统以完全硬件特权运行。这种组织很方便，因为操作系统设计者不必决定操作系统的哪一部分不需要完全的硬件特权。此外，操作系统的不同部分更容易合作。例如，一个操作系统可能有一个缓冲缓存，它可以被文件系统和虚拟内存系统共享。

整体组织的一个缺点是操作系统不同部分之间的接口通常很复杂(我们将在本文的其余部分看到)，因此对于操作系统开发者来说更容易出现纰漏，在单体内核组织中，每一个错误都是致命的，因为管理者模式下的一个错误会导致内核崩溃，如果内核崩溃，计算机停止工作，那么运行在其上的所有应用程序都会崩溃。计算机就需要重新启动。

为了减少在内核中出错的风险，操作系统设计者可以尽量减少在管理模式下运行的操作系统代码的数量，并在用户模式下执行大部分操作系统。这种内核组织称为微内核。

**微内核：**

下图展示了微内核的设计：

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20240326162349584.png" alt="image-20240326162349584" style="zoom:50%;" />

在上图中，文件系统作为一个用户空间的程序运行。作为进程运行的操作系统服务称为服务器。为了允许应用程序与文件服务器交互，内核提供了一个进程间通信机制，将消息从一个用户模式进程发送到另一个用户模式进程。例如，如果像shell这样的应用程序想要读取或写入文件，它会向文件服务器发送消息并等待响应。在微内核中，内核接口由几个低级函数组成，用于启动应用程序、发送消息、访问设备硬件等。这种组织允许内核相对简单，因为大多数操作系统驻留在用户级服务器中。



与大多数Unix操作系统一样，Xv6是作为一个单体内核实现的。因此，xv6内核接口对应于操作系统接口，内核实现完整的操作系统。由于xv6不提供很多服务，它的内核比一些微内核要小，但从概念上讲，xv6是整体的。

## 四、Xv 6 代码

Xv6 内核源代码位于“kernel/”子目录下。按照模块化的粗略概念，源代码被分成多个文件。下图展示了这些文件。模块之间的接口在 def.h 中定义。

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20240326163031040.png" alt="image-20240326163031040" style="zoom:50%;" />

## 五、进程概览

在 xv6 (与其他Unix操作系统一样)中，隔离单元是一个进程。进程抽象可以防止一个进程破坏或监视另一个进程的内存、CPU、文件描述符等。它还可以防止进程破坏内核本身，这样进程就不能破坏内核的隔离机制。内核必须小心地实现进程抽象，因为有bug或恶意的应用程序可能会欺骗内核或硬件做一些不好的事情(例如，绕过隔离)。内核用来实现进程的机制包括用户/管理者模式标志、地址空间和线程的时间切片。

为了帮助实现隔离，进程抽象为程序提供了一种错觉，即它拥有自己的私有机器。进程为程序提供了一个私有的内存系统或地址空间，其他进程无法读取或写入。进程还为程序提供了自己的CPU来执行程序的指令。
Xv6使用页表(由硬件实现)为每个进程提供自己的地址空间。RISC-V页表将虚拟地址(RISC-V指令操作的地址)转换(或“映射”)到物理地址(CPU芯片发送到主存的地址)。

Xv6为每个进程维护一个单独的页表，用于定义该进程的地址空间。如图2.3所示，地址空间包括从虚拟地址0开始的进程用户内存。首先是指令，然后是全局变量，然后是堆栈，最后是进程可以根据需要扩展的“堆”区域(对于malloc)。有许多因素限制了进程地址空间的最大大小:RISC-V上的指针是64位宽的;当在页表中查找虚拟地址时，硬件只使用低39位;而xv6只使用这39位中的38位。因此，最大地址为238−1 = 0x3fffffffff，即MAXVA (kernel/riscv.h:363)。在地址空间的顶部，xv6为 trampoline 保留了一个页面，并为映射进程的 trapframe 保留了一个页面。Xv6使用这两个页面转换到内核和返回内核;蹦床页面包含在内核内外转换的代码，映射trapframe对于保存/恢复用户进程的状态是必要的，我们将在第4章中解释。

> Trampoline页面和Trapframe页面是两个不同的概念，虽然它们都与操作系统内核中的异常处理有关。
>
> Trampoline页面（也称为跳板页）是一种用于在不同的特权级别或执行环境之间进行跳转和传递控制的机制。当操作系统需要从一个执行环境切换到另一个执行环境时，会使用Trampoline页面来完成这个过程。例如，在从用户空间进入内核空间时，操作系统需要通过Trampoline页面将控制权传递给内核代码，以便内核可以处理相应的系统调用或异常。
>
> Trapframe页面（也称为陷阱帧页）则是一种用于保存当前运行线程上下文信息的机制。当操作系统捕获到一个异常或中断时，会将当前线程上下文信息保存到Trapframe页面中，并且在处理完异常后恢复现场，继续执行原先被打断的代码。具体来说，Trapframe页面通常包含了程序计数器、栈指针、寄存器值等当前线程运行状态信息。

内核为每个进程维护许多类型的状态，这些状态集合为一个struct进程(kernel/proc.h:86)。进程最重要的内核状态是它的页表、内核堆栈和运行状态。我们将使用符号p->xxx来指代过程结构的元素;例如，p->pagetable是指向进程页表的指针。

每个进程都有一个执行线程(简称线程)来执行该进程的指令。线程可以挂起，稍后再恢复。为了在进程之间透明地切换，内核挂起当前正在运行的线程并恢复另一个进程的线程。线程的大部分状态(局部变量、函数调用返回地址)都存储在线程的堆栈中。每个进程有两个堆栈:用户堆栈和内核堆栈(p->kstack)。当进程执行用户指令时，只有它的用户堆栈在使用，而它的内核堆栈是空的。当进程进入内核时(对于系统调用或中断)，内核代码在进程的内核堆栈上执行;当进程处于内核中时，它的用户栈仍然包含保存的数据，但是不会被主动使用。进程的线程在主动使用其用户堆栈和内核堆栈之间交替。内核堆栈是独立的(并且不受用户代码的影响)，因此即使进程破坏了它的用户堆栈，内核也可以执行。

进程可以通过执行RISC-V调用指令来进行系统调用。该指令提高硬件特权级别，并将程序计数器更改为内核定义的入口点。入口点的代码切换到内核堆栈，并执行实现系统调用的内核指令。当系统调用完成时，内核切换回用户堆栈，并通过调用sret指令返回到用户空间，这降低了硬件特权级别，并在系统调用指令之后恢复执行用户指令。进程的线程可以在内核中“阻塞”以等待I/O，并在I/O完成后恢复到它离开的地方。
p->state表示进程是已分配、准备运行、正在运行、等待I/O还是退出。
p->pagetable保存进程的页表，以RISC-V硬件期望的格式。当在用户空间中执行进程时，Xv6使分页硬件使用该进程的p->分页表。进程的页表还充当分配给存储进程内存的物理页的地址记录。
总而言之，一个进程捆绑了两个设计思想:一个地址空间，给进程一个自己内存的错觉;一个线程，给进程一个自己CPU的错觉。在xv6中，一个进程由一个地址空间和一个线程组成。在实际操作系统中，一个进程可能有多个线程来利用多个cpu。

## 六、Xv6 是如何开始运行的

