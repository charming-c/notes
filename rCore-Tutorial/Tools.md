# GDB 在 rCore 实验中的使用

**启动 Qemu 并监听端口等待 GDB 连接**

```shell
qemu-system-riscv64 \
    -machine virt \
    -nographic \
    -bios ../bootloader/rustsbi-qemu.bin \
    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000 \
    -s -S
```

`-s` 可以使 Qemu 监听本地 TCP 端口 1234 等待 GDB 客户端连接，而 `-S` 可以使 Qemu 在收到 GDB 的请求后再开始运行。

**打开 GDB 客户端连接 Qemu**

```shell
riscv64-unknown-elf-gdb \
    -ex 'file target/riscv64gc-unknown-none-elf/release/os' \
    -ex 'set arch riscv:rv64' \
    -ex 'target remote localhost:1234'
[GDB output]
0x0000000000001000 in ?? ()
```

## 常用 GDB 命令

- 执行下一条指令：`si`
- `n` 执行下一行代码，不进入函数
- `ni` 执行下一条指令（跳转指令则执行至返回）
- `s` 执行下一行代码，进入函数
- 打印寄存器的值：`p/x $t0`（x 表示 16 进制，d 表示 10 进制）
- 断点调试：`b *地址`
- 运行到下一个断点：`continue`

# RISC-V 架构

RISC-V 架构上的 C 语言调用规范可以在 [这里](https://riscv.org/wp-content/uploads/2015/01/riscv-calling.pdf) 找到。

**关于在函数调用控制流中，如何保证函数调用结束以后，执行调用函数的后一条指令执行**

在 RISC-V 架构中，有这样的两条指令：

|           指令            |             功能             |
| :-----------------------: | :--------------------------: |
|    jal rd, imm[20 : 1]    | rd ← pc + 4    pc ← pc + imm |
| jalr rd, (imm[11 : 0]) rs | rd ← pc + 4    pc ← rs + imm |

> **RISC-V 指令各部分含义**
>
> 在大多数只与通用寄存器打交道的指令中， rs 表示 **源寄存器** (Source Register)， imm 表示 **立即数** (Immediate)，是一个常数，二者构成了指令的输入部分；而 rd 表示 **目标寄存器** (Destination Register)，它是指令的输出部分。rs 和 rd 可以在 32 个通用寄存器 x0~x31 中选取。但是这三个部分都不是必须的，某些指令只有一种输入类型，另一些指令则没有输出部分。其中 RISC-V 指令默认是 32 位的，imm[20 : 0] 表示立即数在指令中的位置是第 0 位到第 20 位。

从上面的指令可以看出，在执行函数控制流跳转时，设置 PC 之前，会将下一条指令也就是 pc+4 保存到 rd 寄存器中。在 RISC-V 指令集中，通常使用`ra`寄存器（即`x1`寄存器）作为其中的`rd`的实际寄存器。事实上，在函数返回的时候我们常常使用一条汇编伪指令跳转回调用之前的位置：`ret`。他会被汇编器翻译为`jalr x0, 0(x1)`，实际的作用含义为跳转到 `ra`也就是`x1`寄存器中的位置中执行。由于`x0`是一个恒为 0 的寄存器，所以`x1`保存到`x0`这一步就被省略了。

**函数嵌套**

由于`ra`寄存器是保存着当前函数调用结束后的下一条指令的地址，所以在函数执行的过程中是不应该被修改的，可是遇到了函数嵌套的调用怎么办？因此在控制流转移前后需要保持不变的寄存器集合称为函数调用上下文。寄存器分为**被调用者保存（callee-saved）**和**调用者保存（caller-saved）**。无论是调用函数还是被调用函数，都会因调用行为而需要两段匹配的保存和恢复寄存器的汇编代码，可以分别将其称为 **开场** (Prologue) 和 **结尾** (Epilogue)，它们会由编译器帮我们自动插入，来完成相关寄存器的保存与恢复。一个函数既有可能作为调用者调用其他函数，也有可能作为被调用者被其他函数调用。

## 寄存器组

| 寄存器组                  | 保存者       | 功能                                                     |
| ------------------------- | ------------ | -------------------------------------------------------- |
| a0~a7（ `x10~x17` ）      | 调用者保存   | 用来传递输入参数。其中的 a0 和 a1 还用来保存返回值。     |
| t0~t6( `x5~x7,x28~x31` )  | 调用者保存   | 作为临时寄存器使用，在被调函数中可以随意使用无需保存。   |
| s0~s11( `x8~x9,x18~x27` ) | 被调用者保存 | 作为临时寄存器使用，被调函数保存后才能在被调函数中使用。 |

剩下的 `x0-x4`:

- `x0`：恒为 0
- `x1/ra`：是被调用者保存的。我们知道在一个函数的控制流指令执行时， `ra`是在子函数调用时的`jal/jalr`指令设置的，也就是说，此时`ra`的值就会被覆盖，为了保存之前的值，就必须在这之前保存，而保存的值是本函数作为被调用函数起作用的，所以是被调用者保存。
- `sp(x2)`栈指针寄存器被调用者保存。
    - 我的理解：在函数调用后，通常需要为函数分配栈空间的，不管是其他被调用保存寄存器的值、多出来的形参值、局部变量等等都是保存在栈空间中，而函数调用结束以后，栈空间应该被回收，回到函数调用前的情况，这就是一个标准的被调用者保存寄存器的保存和恢复。
- fp( `s0` )，它既可作为s0临时寄存器，也可作为栈帧指针（Frame Pointer）寄存器，表示当前栈帧的起始位置，是一个被调用者保存寄存器。fp 指向的栈帧起始位置 和 sp 指向的栈帧的当前栈顶位置形成了所对应函数栈帧的空间范围。
- gp( `x3` ) 和 tp( `x4` ) 在一个程序运行期间都不会变化，因此不必放在函数调用上下文中。

**栈帧 stack frame**

<img src="https://raw.githubusercontent.com/charming-c/image-host/master/img/image-20240714163412799.png" alt="image-20240714163412799" style="zoom:50%;" />

它的开头和结尾分别在 sp(x2) 和 fp(s0) 所指向的地址。按照地址从高到低分别有以下内容，它们都是通过 `sp` 加上一个偏移量来访问的：

- `ra` 寄存器保存其返回之后的跳转地址，是一个被调用者保存寄存器；
- 父亲栈帧的结束地址 `fp` ，是一个被调用者保存寄存器；
- 其他被调用者保存寄存器 `s1` ~ `s11` ；
- 函数所使用到的局部变量。

一个简单的 64 位 8 字节汇编的函数调用的例子：

```assembly
# 开场
# 为当前函数分配 64 字节的栈帧
addi        sp, sp, -64
# 将 ra 和 fp 压栈保存
sd  ra, 56(sp)
sd  s0, 48(sp)
# 更新 fp 为当前函数栈帧顶端地址
addi        s0, sp, 64

# 函数执行
# 中间如果再调用了其他函数会修改 ra

# 结尾
# 恢复 ra 和 fp
ld  ra, 56(sp)
ld  s0, 48(sp)
# 退栈
addi        sp, sp, 64
# 返回，使用 ret 指令或其他等价的实现方式
ret
```

